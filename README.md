# OpenCL course at ITMO University in 2020.

## Лабораторная работа 1: Умножение матриц

**Цель работы:** освоить базовые принципы работы с OpenCL и эффективное использование локальной памяти.

**Описание:**

Реализовать на OpenMP и OpenCL алгоритм, вычисляющий произведение матриц.

OpenCL девайс-код должен быть реализован в отдельном файле и иметь прототип:

```kernel void matrix_mul(global const float *a, global const float *b, global float *c, uint N, uint K, uint M);```

где `a`, `b` – входные матрицы, `c` – выходная матрица, `N`, `M` – ширина и высота выходной матрицы, `K` – общая размерность входных матриц.

Размеры локальной группы: `TILE_W` x `TILE_H` – дефайны, устанавливаемые хост-кодом.

Если kernel имеет ограничение на допустимые размеры локальной группы или количество глобальных элементов не соответствует размеру выходной матрицы – это необходимо явно указать в комментарии перед прототипом.

Хост-код должен обеспечивать автоматический выбор OpenCL платформы и запуск kernel’а на GPU (при наличии такого устройства, предпочитая дискретную видеокарту) или на CPU (в противном случае). Запуск должен производиться на случайно сгенерированных матрицах размером `N = 2048`, `K = 512`, `M = 1024`, проверяться правильность результата, измеряться время выполнения kernel’а и выводиться значение достигнутых GFLOPS (арифметических действий, непосредственно вычисляющих значения матрицы результата, то есть без учёта пересылки данных, вычисления индексов,...).

Минимальная версия: параллельный алгоритм с использованием локальной памяти.

Полная версия: оптимизация скорости, обработкой нескольких элементов в одном треде; использование векторных типов данных.

## Лабораторная работа 2: Префиксная сумма

**Цель работы:** освоить эффективное распределение работы по тредам внутри групп.

**Описание:**

Реализовать на OpenCL алгоритм, вычисляющий инклюзивную префиксную сумму.

OpenCL девайс-код должен быть реализован в отдельном файле.

Тип данных: `float`.

Хост-код должен обеспечивать автоматический выбор OpenCL платформы и запуск kernel’а на GPU (при наличии такого устройства, предпочитая дискретную видеокарту) или на CPU (в противном случае). Запуск должен производиться на случайно сгенерированных данных, проверяться правильность результата, измеряться время выполнения kernel’ов (суммарное по каждому и общее).

Минимальная версия: параллельный алгоритм с использованием локальной памяти, данные умещаются в одну локальную группу.

Полная версия: произвольный объём данных.
